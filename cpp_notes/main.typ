#import "../templates/notes_template.typ": *
#let course = "Язык программирования C++"
#let title = "Конспект лекций"
#show: footer_header.with(
  title,
  course
)
#show: title_page.with(
  title,
  course
)
#show: page_settings

= Лекция 1.
TODO
#pagebreak()

= Лекция 2.
TODO
#pagebreak()

= Лекция 3
TODO
#pagebreak()

#pagebreak()
= Лекция 4.
== Функции.
Программы на C++ выглядят, как множество функций, которые друг друга вызывают, поэтому фактически невозможно запустить код вне функций.\
Уже знакомая нам функция --- `main`. Программа запускает ее автоматически, а в конце получает от нее: успешно ли выполнилась программа.
#parbreak()
Очевидно, создавать можно и свои функции. Рассмотрим пример:
```cpp
int add(int a, int b) {
  return a + b;
}
```
Сначала задается тип возращаемого результата функции, после -- название, а наконец аргументы, каждый с своим типом данных. Каждая функция заканчивается ключевым словом `return`, который возвращает значение функции.\
Команда `return` не обязятельно должна стоять в самом конце кода функции. Например, их можно поставить несколько, некоторые в середину
```cpp
int add(int a, int b) {
  if (a == 0 && b == 0){
    return 0;
  }
  return a + b;
}
```
Важно помнить, что на `return` функция возвращает свое значение и заканчивает выполнение.
#parbreak()
Есть функции, которые ничего не возвращают:
```cpp
void foo() {
  std::cout << "nothing" << std::endl;
}
```
Вызываются функции любые функции одинаково:
```cpp
int main() {
  std::cout << add(1, 2) << std::endl;
  std::cout << add(3, 3) << std::endl;

  foo();
  foo();
}
```
#linebreak()
На самом деле, функция `main` тоже принимает аргументы...\
TODO

#pagebreak()
= Лекция 5.
TODO

#pagebreak()
= Лекция 6.
== Строки.
Немного общее про хранение символов. Поскольку символов много, а их все надо как-то однозначно определить, придумали кодировки. Они позволяют хранить в памяти просто номер код символа, а программа уже сама будет по этому коду определять, какой символ рисоватью.\
Например, есть кодировка `utf-8`. Она хранит символы Unicode и занимает 8 бит или 1 байт. Коды символов имеют полную обратную совместимость с 7-битной кодировкой ASCII.\
В С++ по умолчанию используется `utf-8`.
#parbreak() #linebreak()
В С++ строку можно хранить, например, как просто массив элементов типа ```cpp char```. Будет не более 256 различных значений.
```cpp
char str[] = {'H', 'e', 'l', 'l', 'o'};
std::cout << str << std::endl;
```
На этот код санитайзер будет ругаться. Для вывода этого массива в ```cpp std::cout``` передается указатель на первый символ, ```cpp char* ptr = &str[0]```. Выходит так, чтобы вывести строку, программа должна пройтись по памяти, начиная с адреса начала строки, однако она не знает, где остановиться, и выходит за его пределы. Но далее программа может просто дойти до конца выделенной ей памяти и сломаться --- что она и делает. В этот момент санитайзер предуперждает, что мы вышли за пределы памяти.
#parbreak()
Тогда можно выводить строку такой функцией:
```cpp
void print(const char* str, size_t size) {
  while (size > 0) {
    std::cout << *str << std::flush;
    ++str;
    --size;
  }
}
```
Или можно задавать размер заранее, прямо в строке:
```cpp
// const char str[] = {0, 0, 0, 5, 'H', 'e', 'l', 'l', 'o'}; //первые 4 байта -- размер строки

void print(const char *str) {
  size_t size = 0;
  for (int i = 0; i < 4; ++i) {
    size <<= std::numeric_limits<unsigned char>::digits;
    size |= *str++;
  }

  while (size > 0) {
    std::cout << *str << std::flush;
    str++;
    size--;
  }
}
```
#pagebreak()
Теперь о строках. В каждой строке, помимо самих символов стоки, есть и специальный символ конца строки: ```cpp '\o'```. Поэтому, опеределив строку через двойные кавычки, мы можем выводить так:
```cpp
void print0(const char* str) {
  while (*str != '\0') {
    std::cout << *str++;
  }
}

int main() {
  char str[] = "abcde";
  print0(str);

  return 0;
}
```
Однако, и у строк есть свои минусы: мы не можем знать длину строки за O(1). Чтобы узнать длину, мы должны пройти по всей строки, от адреса начала, до символа ```cpp '\o'```.
#pagebreak()

== Структуры.
Хорошо бы уметь хранить строку и ее размер в одном месте, в одной структуре. Для этого есть структуры.
```cpp
struct StringRef {
  const char* begin;
  size_t size;
}

struct OwningString {
  char str[100];  // здесь 100 -- длина строки, следовательно займется память на 100 чаров
  // и тут еще будет char padding[7]. (выравнивание)
  size_t size;
}
```
Тогда остальные функции мы можем переписать так:
```cpp
void print(StringRef str) {
  for (size_t i = 0; i < str.size; ++i) {
    std::cout << str.begin[i] << std::endl;
  }
}

int main() {
  const char* ptr = "abcdefg";  // где-то в памяти лежит это строка.
  StringRef str{ptr, 7};
  OwningString str2{"ABCD", 4};
}
```
=== Инициализация структуры.
Можно просто сначала инициализировать и потом поименно прописывать каждое поле:
```cpp
int main() {
  StringRef str;
  str.size = 3;
  beging = "123"
}
```
Можно сразу прописывать при инициализации, но тут важно соблюдать порядок, как они расположены в определении, и заполнять все значения:
```cpp
int main() {
  StringRef str{"123", 3};
  // StringRef str = {"123", 3}; // Можно еще так
}
```
Начиная с С++20 появилась новая схема:
```cpp
int main () {
  StringRef str{
    .begin = "123",
    .size = 3,
  } // Тут надо писать их в том порядке, в каком они задекларированы в определении структуры
}
```
=== Обращаться к полям структуры.
Самое простое -- через точку:
```cpp
std::cout << str.size << std::endl;
```
Если у нас есть указатель на структуры:
```cpp
StringRef ref;
StringRef* ptr = &ref;

(*ptr).size = 42;
// или
ptr->size = 13;
// или
const auto& [begin, size] = ref; // называется распаковка.
// Вся структура разбивается на переменные.
// В квадратных скобках пишутся имена, по которым можно найти переменную.
```
#pagebreak()

= Лекция 7
== Классы
```cpp
struct Point {
  int x;
  int y;
};
```
Пусть есть структура `Rect`:
```cpp
struct BadRect {
  int width = 0;
  int height = 0;
  int area = 0;
};

int GetRectAreaSlow(const BadRect& rect) {
  // ...
}
```

Структуры -- это всего лишь набор переменных, которые никак не  связаны и независимы, но если нам потребуется какая-то связь, то надо использовать классы.
```cpp
class Rect {
public:
  int SetWidth(int new_width) {
    width_ = new_width;
    UpdateArea();
  }

  int Area() const { // const не позволяет менять приватные переменные
    return area_;
  }

private:
  void UpdateArea() {
    area_ = widht_ * height_;
  }

private:
  int width_ = 0;
  int height_ = 0;
  int area_ = 0;
};
```
Классы практически не отличаются от Структур. Единственное отличие -- люди договорились, что структура считается набором полей, а классы еще имеют связи между полями.
=== Модификаторы доступа.
- ```cpp private```: поля и функции можно менять/читать/вызывать только изнутри класса. Другими словами, к ним нет доступа снаружи.
- ```cpp public```: можно менять извне; методы в этом разделе можно вызывать снаружи.
- ```cpp protected```: ...
#parbreak()
Константные поля;
```cpp
public:

```
В константной функции нельзя менять приватные переменные. 
```cpp
int foo() const {

}
``` 
Если в разделе  ```cpp private``` объявить переменную как ```cpp mutable int area```, то ее можон менять даже в ```cpp const``` функции.
```cpp
// код про кэш; пример для использования mutable переменных.
```

Таким образом мы можем обращаться к `RectId` как к типу данных, равному по свойствам `uint64_t`
```cpp
class RectDataBase {
public:
  using RectId = uint64_t;

  Rect GetRect(RectId) {
    // ...
  }
}
```
=== Инициализация класса
Конструктор вызывается автоматически, сразу при создании объекта. Код просто не скомпилируется, пока в конструктор не передадут все важные переменные.
```cpp
class Rect {
public:
  Rect(int width, int height) { // конструктор
    width_ = width;
    height_ = height;
    UpdateArea();
  }  

private:
  void UpdateArea() {
    area_ = widht_ * height_;
  }

private:
  int width_ = 0;
  int height_ = 0;
  int area_ = 0;
}
```
```cpp
  Rect(int width, int height) // другой вид конструктора
    : width_{width}
    , height_{height}
  {}
```
Можно пользоваться также и перегрузкой функций и тогда комиплятор сам будет выбирать нужный конструктор.
#parbreak()
Если есть функция, принимает в себя объект класса, то вызов функции может выглядеть неочевидно:
```cpp
void foo(Rect r){
  ...
}

int main() {
  foo(123);
}
```
Тогад в конструкторе можно указать ключевое слов ```cpp explicit```, и тогда мы будем обязаны в функции указать иначе
```cpp
  int main() {
    foo(Rect{123})
  }
```
=== Деструкторы
Как понятно из названия, вызывается в конце существования объекта.
```cpp
class Noisy {
public:
  Noisy(int idx) {
    // что выполнится при создании объекта
  }
  ~Noisy() {
    // что выполнится в конце существования объекта
  }
}
```
Объект удаляется, как и переменные, в конце блока с `{...}`.
#pagebreak()

= Лекция 8
== Динамическая память
+ Глобальная память --- снаружи всех функций, доступ к ним есть отовсюд. Разрушаются переменные только в конце выполнении программы. Чаще всего надо избегать испольщование глобальных переменных.
+ Автоматический вид памяти. Комиплятор сам -- автоматически -- ращрушает переменные; также автоматически выделяет память.
+ Динамическая память --- объекты живут в памяти ровно столько, сколько прописано в программе.
  ```cpp
  for (int i = 0; i < 1000; ++i) {
    int* ptr = new int{123};
    delete ptr;  // удаляем то, на что указывает указатель
  }

  // объект, который живет в автоматической памяти;
  // указатель живет в автоматической памяти;
  // сам объект указателя живет после delete;
  ```
  Ключевое слово (оператор) ```cpp new``` создает объект и выделяет для него автоматическую память.\
  Когда мы создали объект и потеряли к нему указатель, то мы не больше доступа к нему и не можем удалить. Называется утечкой памяти.\
  Вернуть из блока `{...}` тот указатель:
  ```cpp
  int* allocate() {
    int* ptr = new int{!23};
    return ptr
  }

  int main() {
    int* ptr = allocate();
    delete ptr;

    return 0;
  }
  ```
  Динамическая память живет не на стеке, а на "куче", поэтому там можно хранить большие данные.

  ```cpp
  class UniquePtr {
    UniquePtr(int* ptr) {

    }
  }
  ```

  ```cpp
  std::unique_ptr<int> ptr_main = AllocateSmart();
  std::unique_ptr<int> ptr_main2 = ptr_main; // так нельзя

  std::shared_ptr<int> s1{new int{42}};
  std::shared_ptr<int> s2;
  std::shared_ptr<int> s3;
  ```

#pagebreak()
= Slightly off topic.
== Шрифты.
```
snake_case,
CamelCase,
kebab-case.
```
